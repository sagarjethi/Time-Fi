{"ast":null,"code":"import _toConsumableArray from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ankit/hack/TimeFi/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nexport var TZFinder = /*#__PURE__*/function () {\n  function TZFinder(zones) {\n    _classCallCheck(this, TZFinder);\n\n    this.index = void 0;\n    this.all = void 0;\n    this.index = this.createIndex(zones);\n    this.all = zones;\n  }\n\n  _createClass(TZFinder, [{\n    key: \"getAll\",\n    value: function getAll() {\n      return this.all;\n    }\n  }, {\n    key: \"createIndex\",\n    value: function createIndex(TZ) {\n      var index = [];\n\n      var _loop = function _loop() {\n        var _ref = _Object$entries[_i];\n        _ref2 = _slicedToArray(_ref, 2);\n        var key = _ref2[0];\n        var values = _ref2[1];\n        values.forEach(function (value, localeIndex) {\n          var _value = _slicedToArray(value, 1),\n              locale = _value[0];\n\n          index.push({\n            str: TZFinder.splitUniq(key, locale),\n            val: value,\n            path: [key, localeIndex]\n          });\n        });\n      };\n\n      for (var _i = 0, _Object$entries = Object.entries(TZ); _i < _Object$entries.length; _i++) {\n        var _ref2;\n\n        _loop();\n      }\n\n      return index;\n    }\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(word) {\n        var index,\n            obj,\n            re,\n            matches,\n            _iterator,\n            _step,\n            _ref5,\n            path,\n            val,\n            _path,\n            cont,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = _args.length > 1 && _args[1] !== undefined ? _args[1] : this.index;\n                obj = {};\n                re = new RegExp(word, \"i\");\n                matches = index.filter(function (_ref3) {\n                  var str = _ref3.str;\n                  return str.some(function (s) {\n                    return re.test(s);\n                  });\n                });\n                _iterator = _createForOfIteratorHelper(matches);\n                _context.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 17;\n                  break;\n                }\n\n                _ref5 = _step.value;\n                path = _ref5.path;\n                val = _ref5.val;\n                _context.next = 13;\n                return new Promise(function (rs) {\n                  return setImmediate(rs);\n                });\n\n              case 13:\n                _path = _slicedToArray(path, 1), cont = _path[0];\n                (obj[cont] = obj[cont] || []).push(val);\n\n              case 15:\n                _context.next = 7;\n                break;\n\n              case 17:\n                _context.next = 22;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](5);\n\n                _iterator.e(_context.t0);\n\n              case 22:\n                _context.prev = 22;\n\n                _iterator.f();\n\n                return _context.finish(22);\n\n              case 25:\n                return _context.abrupt(\"return\", obj);\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 19, 22, 25]]);\n      }));\n\n      function search(_x) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n  }], [{\n    key: \"normalize\",\n    value: function normalize(text) {\n      return text.toLowerCase().replace(/\\/|,/g, \" \").replace(/  /g, \" \");\n    }\n  }, {\n    key: \"splitUniq\",\n    value: function splitUniq() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _toConsumableArray(new Set(args.map(function (s) {\n        return TZFinder.normalize(s);\n      }).join(\" \").split(\" \")));\n    }\n  }]);\n\n  return TZFinder;\n}();","map":{"version":3,"sources":["/home/ankit/hack/TimeFi/frontend/src/pages/NewEvent/Details/timezoneFinder.ts"],"names":["TZFinder","zones","index","all","createIndex","TZ","key","values","forEach","value","localeIndex","locale","push","str","splitUniq","val","path","Object","entries","word","obj","re","RegExp","matches","filter","some","s","test","Promise","rs","setImmediate","cont","text","toLowerCase","replace","args","Set","map","normalize","join","split"],"mappings":"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","sourcesContent":["export interface TZType {\n  [continent: string]: string[][];\n}\nexport type TZIndexType = Array<{\n  str: string[];\n  val: string[];\n  path: (string | number)[];\n}>;\n\nexport class TZFinder {\n  private index: TZIndexType;\n  private all: TZType;\n\n  constructor(zones: TZType) {\n    this.index = this.createIndex(zones);\n    this.all = zones;\n  }\n\n  getAll() {\n    return this.all;\n  }\n\n  private static normalize(text: string) {\n    return text\n      .toLowerCase()\n      .replace(/\\/|,/g, \" \")\n      .replace(/  /g, \" \");\n  }\n\n  private static splitUniq(...args: string[]) {\n    return [\n      ...new Set(\n        args\n          .map(s => TZFinder.normalize(s))\n          .join(\" \")\n          .split(\" \")\n      )\n    ];\n  }\n\n  private createIndex(TZ: TZType): TZIndexType {\n    let index: TZIndexType = [];\n    for (let [key, values] of Object.entries(TZ)) {\n      values.forEach((value, localeIndex) => {\n        let [locale] = value;\n        index.push({\n          str: TZFinder.splitUniq(key, locale),\n          val: value,\n          path: [key, localeIndex]\n        });\n      });\n    }\n    return index;\n  }\n\n  async search(word: string, index: TZIndexType = this.index) {\n    let obj: TZType = {};\n    let re = new RegExp(word, \"i\");\n    let matches = index.filter(({ str }) => str.some(s => re.test(s)));\n    for (let { path, val } of matches) {\n      await new Promise(rs => setImmediate(rs));\n      let [cont] = path;\n      (obj[cont] = obj[cont] || []).push(val);\n    }\n    return obj;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}